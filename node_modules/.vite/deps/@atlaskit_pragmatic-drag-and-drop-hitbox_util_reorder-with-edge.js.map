{
  "version": 3,
  "sources": ["../../../../node_modules/@atlaskit/pragmatic-drag-and-drop/dist/esm/public-utils/reorder.js", "../../../../node_modules/@atlaskit/pragmatic-drag-and-drop-hitbox/dist/esm/get-reorder-destination-index.js", "../../../../node_modules/@atlaskit/pragmatic-drag-and-drop-hitbox/dist/esm/reorder-with-edge.js"],
  "sourcesContent": ["import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\n/**\n * Reorder a provided `list`\n * Returns a new array and does not modify the original array\n */\nexport function reorder(_ref) {\n  var list = _ref.list,\n    startIndex = _ref.startIndex,\n    finishIndex = _ref.finishIndex;\n  if (startIndex === -1 || finishIndex === -1) {\n    return list;\n  }\n  var result = Array.from(list);\n  var _result$splice = result.splice(startIndex, 1),\n    _result$splice2 = _slicedToArray(_result$splice, 1),\n    removed = _result$splice2[0];\n  result.splice(finishIndex, 0, removed);\n  return result;\n}", "export function getReorderDestinationIndex(_ref) {\n  var startIndex = _ref.startIndex,\n    closestEdgeOfTarget = _ref.closestEdgeOfTarget,\n    indexOfTarget = _ref.indexOfTarget,\n    axis = _ref.axis;\n  // invalid index's\n  if (startIndex === -1 || indexOfTarget === -1) {\n    return startIndex;\n  }\n\n  // if we are targeting the same index we don't need to do anything\n  if (startIndex === indexOfTarget) {\n    return startIndex;\n  }\n  if (closestEdgeOfTarget == null) {\n    return indexOfTarget;\n  }\n  var isGoingAfter = axis === 'vertical' && closestEdgeOfTarget === 'bottom' || axis === 'horizontal' && closestEdgeOfTarget === 'right';\n  var isMovingForward = startIndex < indexOfTarget;\n  // moving forward\n  if (isMovingForward) {\n    return isGoingAfter ? indexOfTarget : indexOfTarget - 1;\n  }\n  // moving backwards\n  return isGoingAfter ? indexOfTarget + 1 : indexOfTarget;\n}", "import { reorder } from '@atlaskit/pragmatic-drag-and-drop/reorder';\nimport { getReorderDestinationIndex } from './get-reorder-destination-index';\nexport function reorderWithEdge(_ref) {\n  var list = _ref.list,\n    startIndex = _ref.startIndex,\n    closestEdgeOfTarget = _ref.closestEdgeOfTarget,\n    indexOfTarget = _ref.indexOfTarget,\n    axis = _ref.axis;\n  return reorder({\n    list: list,\n    startIndex: startIndex,\n    finishIndex: getReorderDestinationIndex({\n      closestEdgeOfTarget: closestEdgeOfTarget,\n      startIndex: startIndex,\n      indexOfTarget: indexOfTarget,\n      axis: axis\n    })\n  });\n}"],
  "mappings": ";;;;;;AAKO,SAAS,QAAQ,MAAM;AAC5B,MAAI,OAAO,KAAK,MACd,aAAa,KAAK,YAClB,cAAc,KAAK;AACrB,MAAI,eAAe,MAAM,gBAAgB,IAAI;AAC3C,WAAO;AAAA,EACT;AACA,MAAI,SAAS,MAAM,KAAK,IAAI;AAC5B,MAAI,iBAAiB,OAAO,OAAO,YAAY,CAAC,GAC9C,kBAAkB,eAAe,gBAAgB,CAAC,GAClD,UAAU,gBAAgB,CAAC;AAC7B,SAAO,OAAO,aAAa,GAAG,OAAO;AACrC,SAAO;AACT;;;AClBO,SAAS,2BAA2B,MAAM;AAC/C,MAAI,aAAa,KAAK,YACpB,sBAAsB,KAAK,qBAC3B,gBAAgB,KAAK,eACrB,OAAO,KAAK;AAEd,MAAI,eAAe,MAAM,kBAAkB,IAAI;AAC7C,WAAO;AAAA,EACT;AAGA,MAAI,eAAe,eAAe;AAChC,WAAO;AAAA,EACT;AACA,MAAI,uBAAuB,MAAM;AAC/B,WAAO;AAAA,EACT;AACA,MAAI,eAAe,SAAS,cAAc,wBAAwB,YAAY,SAAS,gBAAgB,wBAAwB;AAC/H,MAAI,kBAAkB,aAAa;AAEnC,MAAI,iBAAiB;AACnB,WAAO,eAAe,gBAAgB,gBAAgB;AAAA,EACxD;AAEA,SAAO,eAAe,gBAAgB,IAAI;AAC5C;;;ACvBO,SAAS,gBAAgB,MAAM;AACpC,MAAI,OAAO,KAAK,MACd,aAAa,KAAK,YAClB,sBAAsB,KAAK,qBAC3B,gBAAgB,KAAK,eACrB,OAAO,KAAK;AACd,SAAO,QAAQ;AAAA,IACb;AAAA,IACA;AAAA,IACA,aAAa,2BAA2B;AAAA,MACtC;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF,CAAC;AAAA,EACH,CAAC;AACH;",
  "names": []
}
